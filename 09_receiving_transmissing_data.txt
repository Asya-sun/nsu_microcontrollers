.include "m168def.inc"

.DSEG
string_buffer: .byte 51      ; ????? ?? 50 ???????? + CR
write_ptr:     .byte 2       ; ????????? ?????? (16-??????)
read_ptr:      .byte 2       ; ????????? ?????? (16-??????)
buffer_ready:  .byte 1       ; ???? ?????????? ??????
transmit_active: .byte 1     ; ???? ?????????? ????????
byte_count:		.byte 1
array: .byte 10 ;
read_write_flag:	.byte 1

.CSEG
.org 0x0000
    rjmp start               ; Reset Handler
.org 0x0024
    rjmp USART_RX_ISR        ; USART Rx Complete
.org 0x0026
    rjmp USART_UDRE_ISR      ; USART UDRE Ready

.def tmp = r16

start:
    cli                      ; ????????? ??????????
    ; ????????????? ?????
    ldi tmp, LOW(RAMEND)
    out SPL, tmp
    ldi tmp, HIGH(RAMEND)
    out SPH, tmp

    ; ????????????? ??????????
    ldi XL, LOW(string_buffer)
    ldi XH, HIGH(string_buffer)
    sts write_ptr, XL
    sts write_ptr+1, XH
    sts read_ptr, XL
    sts read_ptr+1, XH

    clr tmp
    sts buffer_ready, tmp    ; ???????? ???? ??????????
    sts transmit_active, tmp ; ???????? ???? ????????
	sts byte_count, tmp
	sts read_write_flag, tmp

	LDI 	ZL,low(array) 
	LDI 	ZH,high(array)
	clr tmp

fillaray:
	st Z+, tmp // (z) <-r16; z<-z +1
	
	inc tmp // r16 <- r16 +1
	cpi tmp, 10 // compare
	breq find_break 
    rjmp fillaray

find_break:

    rcall USART_Init
    sei                      ; ????????? ??????????

MAIN_LOOP:
    lds tmp, buffer_ready
    cpi tmp, 1
    brne MAIN_LOOP           ; ???? ?????????? ??????


	; start transmission
    ldi tmp, 1
    sts transmit_active, tmp ; ?????????? ???? ????????
    clr tmp
    sts buffer_ready, tmp    ; ???????? ???? ??????????

    
	; check if we got 5 bytes (4 + CR)
	lds tmp, byte_count
	cpi tmp, 5
	breq check_valid

	rjmp error_input

input_valid:

	lds tmp, read_write_flag
	cpi tmp, 'w'
	breq write_operation
	rjmp read_operation


send_first_byte:
    ; read first byte from buffer
    lds XL, read_ptr
    lds XH, read_ptr+1
    ld tmp, X+
    sts read_ptr, XL
    sts read_ptr+1, XH
	; send bit
    sts UDR0, tmp            ; ????????? ????????
    

    
    rjmp MAIN_LOOP


write_operation:
	ldi  ZL, low(string_buffer + 2)
    ldi  ZH, high(string_buffer + 2)
	;index
    ld   r17, Z

	ldi  ZL, low(string_buffer + 3)
    ldi  ZH, high(string_buffer + 3)
	;value
    ld   r18, Z

	ldi ZH, high(array)  ; Загружаем старший байт адреса массива
	ldi ZL, low(array)   ; Загружаем младший байт адреса массива
	add ZL, r17
	clr tmp
	adc ZH, tmp
	st Z, r18
	; it's not error, we just do everything we wanted
	rjmp error_input

read_operation:
	ldi  ZL, low(string_buffer + 2)
    ldi  ZH, high(string_buffer + 2)
	;index
    ld   r17, Z

	
	ldi ZH, high(array)
	ldi ZL, low(array)
	add ZL, r17 
	clr tmp
	adc ZH, tmp
	; r18 = array[r17]
	ld r18, Z             
	

	ldi  ZL, low(string_buffer + 1)
    ldi  ZH, high(string_buffer + 1)
	st Z, r17

	ldi  ZL, low(string_buffer + 2)
    ldi  ZH, high(string_buffer + 2)
	st Z, r18

	ldi  ZL, low(string_buffer + 3)
    ldi  ZH, high(string_buffer + 3)
	ldi tmp, 13
	st Z, tmp
	rjmp send_first_byte



check_valid:
    ; load second byte (index 1)
    ldi  ZL, low(string_buffer + 1)
    ldi  ZH, high(string_buffer + 1)
    ld   tmp, Z
    
    ; check it r/w
    cpi  tmp, 'r'
	breq set_flag_read
	sts read_write_flag, tmp
    cpi  tmp, 'w'
    brne error_input  

set_flag_read:
	sts read_write_flag, tmp
	breq check_third_byte

check_third_byte:
    ; load third byte (index 2)
    ldi  ZL, low(string_buffer + 2)
    ldi  ZH, high(string_buffer + 2)
    ld   tmp, Z
    
    ; Проверяем что значение между '0' и '9' (ASCII)
    cpi  tmp, 0
    brlo error_input  ; Если меньше '0' - ошибка
    cpi  tmp, 9 + 1
    brsh error_input  ; Если больше '9' - ошибка

    ; last byte is cr
    rjmp input_valid



error_input:

	clr tmp
    sts transmit_active, tmp
	sts read_write_flag, tmp

    ; ???????? ?????????
    ldi XL, LOW(string_buffer)
    ldi XH, HIGH(string_buffer)
    sts read_ptr, XL
    sts read_ptr+1, XH
    sts write_ptr, XL
    sts write_ptr+1, XH

	; if we got error input, do nothing
	clr tmp
	sts transmit_active, tmp
	sts byte_count, tmp
	rjmp MAIN_LOOP


	

USART_Init:
    ; ????????? USART
    ldi tmp, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)|(1<<UDRIE0)
    sts UCSR0B, tmp

    ; ??????????? ?????, 8 ???
    ldi tmp, (1<<UCSZ01)|(1<<UCSZ00) 
    sts UCSR0C, tmp

    ; ????????? ???????? 9600 ??? 16 ???
    ldi tmp, HIGH(103)
    sts UBRR0H, tmp
    ldi tmp, LOW(103)
    sts UBRR0L, tmp
    ret

USART_RX_ISR:
    push tmp
    in tmp, SREG
    push tmp
    push XL
    push XH


	lds tmp, byte_count
	inc tmp
	sts byte_count, tmp

    ; ????????? ????????? ??????
    lds XL, write_ptr
    lds XH, write_ptr+1

    ; ???????? ??????
    lds tmp, UDR0

    ; ????????? ?????? ? ????? (??????? CR)
    st X+, tmp

    ; ???????? ????????? ??????
    sts write_ptr, XL
    sts write_ptr+1, XH

    ; ????????? ?? ????? ?????? (CR)
    cpi tmp, 0x0D            
    breq rx_complete

    ; ????????? ???????????? ??????
    cpi XL, LOW(string_buffer + 50)
    brne rx_exit
    cpi XH, HIGH(string_buffer + 50)
    brne rx_exit

rx_complete:
    ; ?????????? ???? ??????????
    ldi tmp, 1
    sts buffer_ready, tmp

rx_exit:
    pop XH
    pop XL
    pop tmp
    out SREG, tmp
    pop tmp
    reti

USART_UDRE_ISR:
    push tmp
    in tmp, SREG
    push tmp
    push XL
    push XH

    ; ????????? ?????????? ????????
    lds tmp, transmit_active
    cpi tmp, 1
    brne udre_exit           ; ???? ???????? ?? ??????? - ?????

    ; ????????? ????????? ??????
    lds XL, read_ptr
    lds XH, read_ptr+1

    ; check if the last byte - CR
    ld tmp, X
    cpi tmp, 0x0D
    breq transmission_done   ; ???? CR - ????????? ????????

    ; ????????? ????????? ??????
    ld tmp, X+
    sts UDR0, tmp

    ; ???????? ????????? ??????
    sts read_ptr, XL
    sts read_ptr+1, XH
    rjmp udre_exit

transmission_done:
    ; send last symbol (CR)
    ld tmp, X+
    sts UDR0, tmp

    ; ???????? ?????
    clr tmp
    sts transmit_active, tmp
	sts byte_count, tmp

    ; ???????? ?????????
    ldi XL, LOW(string_buffer)
    ldi XH, HIGH(string_buffer)
    sts read_ptr, XL
    sts read_ptr+1, XH
    sts write_ptr, XL
    sts write_ptr+1, XH

udre_exit:
    pop XH
    pop XL
    pop tmp
    out SREG, tmp
    pop tmp
    reti